title: 【译】Java中的垃圾回收机制
date: 2016-05-13 23:28:15
toc: true
comment: true
categories: java
tags: [java, jvm]
---
>感觉人生就是while(true){一个选择接着一个选择接着一个选择;},好怕自己一不小心就做了错误的决定啊😭。堵上全部人品,希望新公司技术氛围浓厚,有大牛带我,切拜🙊🙏。

不扯有的没的了，翻译一篇关于垃圾回收(以下简称GC)机制的博客([原文地址](http://javarevisited.blogspot.com/2011/04/garbage-collection-in-java.html))。博客内容包括：Java中GC是如何工作的，常见的GC算法(比如:标记清除)，Java中不同的垃圾收集器(比如:serial)。
<!-- more -->
### 关键字约定
* Young generation -->新生代
* Tenured / Old Generation -->老年代
* Perm Area -->永久代

### 重要的东东
* 在Java中，对象实例都是在堆上创建。一些类信息，常量，静态变量等存储在方法区。堆和方法区都是线程共享的。
* GC机制是由JVM提供，用来清理需要清除的对象，回收堆内存。
* GC机制将Java程序员从内存管理中解放了出来，可以更关注于业务逻辑。
* 在Java中，GC是由一个被称为垃圾回收器的守护进程执行的。
* 在从内存回收一个对象之前会调用对象的finalize()方法。
* 作为一个Java开发者不能强制JVM执行GC；GC的触发由JVM依据堆内存的大小来决定。
* System.gc()和Runtime.gc()会向JVM发送执行GC的请求，但是JVM不保证一定会执行GC。
* 如果堆没有内存创建新的对象了，会抛出`OutOfMemoryError`。

### GC针对什么对象？
了解GC机制的第一步就是理解什么样的对象会被回收。当一个对象通过一系列根对象(比如：静态属性引用的常量)都不可达时就会被回收。简而言之，当一个对象的所有引用都为null。循环依赖不算做引用，如果对象A有一个指向对象B的引用，对象B也有一个指向对象A的引用，除此之外，它们没有其他引用，那么对象A和对象B都、需要被回收(如下图,ObjA和ObjB需要被回收)。
![GC回收对象](/images/GC-Object.png)
### 堆内存是如何划分的？
Java中对象都在堆上创建。为了GC，堆内存分为三个部分，也可以说三代，分别称为新生代，老年代和永久代。其中新生代又进一步分为Eden区，Survivor 1区和Survivor 2区(如下图)。新创建的对象会分配在Eden区,在经历一次Minor GC后会被移到Survivor 1区，再经历一次Minor GC后会被移到Survivor 2区，直到升至老年代,需要注意的是，一些大对象(长字符串或数组)可能会直接存放到老年代。
![堆内存](/images/堆内存.png)
永久代有一些特殊，它用来存储类的元信息。对于GC是否发生在永久代有许多不同的看法，在我看来这取决于采用的JVM。大家可以通过创建大量的字符串来观察是发生了GC还是抛出了OutOfMemoryError。
### GC算法
1. 标记清除算法
分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法的缺点是效率不高并且会产生不连续的内存碎片。
![image](/images/sweep.jpg)
2. 复制算法
把内存空间划为两个区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。优点：实现简单，运行高效。缺点：会浪费一定的内存。一般新生代采用这种算法。
![image](/images/copy.jpg)
3. 标记整理算法
标记阶段与标记清除算法一样。但后续并不是直接对可回收的对象进行清理，而是让所有存活对象都想一端移动，然后清理。优点是不会造成内存碎片。
![image](/images/compact.jpg)


### Java中垃圾回收器的类型
Java提供多种类型的垃圾回收器。JVM中的垃圾收集一般都采用“分代收集”，不同的堆内存区域采用不同的收集算法，主要目的就是为了增加吞吐量或降低停顿时间。
* Serial收集器：新生代收集器，使用复制算法，使用一个线程进行GC，串行，其它工作线程暂停。
* ParNew收集器：新生代收集器，使用复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。
* Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾。
* Serial Old收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。
* Parallel Old收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理算法，在Parallel Old执行时，仍然需要暂停其它线程。
* CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见Full GC和并发垃圾回收一节），当用户线程内存不足时，采用备用方案Serial Old收集。

可以看[Java Performance](http://www.amazon.com/dp/0137142528/?tag=javamysqlanta-20)一书来获取更多关于GC调优的信息。
### 与GC有关的JVM参数
做GC调优需要大量的实践，耐心和对项目的分析。我曾经参与过高容量，低延迟的电商系统，在开发中我们需要通过分析造成Full GC的原因来提高系统性能，在这个过程中我发现做GC的调优很大程度上依赖于对系统的分析，系统拥有怎样的对象以及他们的平均生命周期。
举个例子，如果一个应用大多是短生命周期的对象，那么应该确保Eden区足够大，这样可以减少Minor GC的次数。可以通过`-XX:NewRatio`来控制新生代和老年代的比例，比如-XX:NewRatio=3代表新生代和老年代的比例为1：3。需要注意的是，扩大新生代的大小会减少老年代的大小，这会导致Major GC执行的更频繁，而Major GC可能会造成用户线程的停顿从而降低系统吞吐量。JVM中可以用NewSize和MaxNewSize参数来指定新生代内存最小和最大值，如果两个参数值一样，那么就相当于固定了新生代的大小。
个人建议，在做GC调优之前最好深入理解Java中GC机制，推荐阅读Sun Microsystems提供的有关GC的文档。这个[链接](http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html)可能会对理解GC机制提供一些帮助。下面的图列出了各个区可用的一些JVM参数。
![jvm参数](/images/jvm-parameter.png)
### Full GC和并发垃圾回收
并发垃圾回收器的内存回收过程是与用户线程一起并发执行的。通常情况下，并发垃圾回收器可以在用户线程运行的情况下完成大部分的回收工作，所以应用停顿时间很短。
但由于并发垃圾回收时用户线程还在运行，所以会有新的垃圾不断产生。作为担保，如果在老年代内存都被占用之前，如果并发垃圾回收器还没结束工作，那么应用会暂停，在所有用户线程停止的情况下完成回收。这种情况称作Full GC，这意味着需要调整有关并发回收的参数了。
由于Full GC很影响应用的性能，要尽量避免或减少。特别是如果对于高容量低延迟的电商系统，要尽量避免在交易时间段发生Full GC。
### 总结
* 为了分代垃圾回收，Java堆内存分为3代：新生代，老年代和永久代。
* 新的对象实例会优先分配在新生代，在经历几次Minor GC后(默认15次)，还存活的会被移至老年代(某些大对象会直接在老年代分配)。
* 永久代是否执行GC，取决于采用的JVM。
* Minor GC发生在新生代，当Eden区没有足够空间时，会发起一次Minor GC，将Eden区中的存活对象移至Survivor区。Major GC发生在老年代，当升到老年代的对象大于老年代剩余空间时会发生Major GC。
* 发生Major GC时用户线程会暂停，会降低系统性能和吞吐量。
* JVM的参数-Xmx和-Xms用来设置Java堆内存的初始大小和最大值。依据个人经验这个值的比例最好是1:1或者1:1.5。比如，你可以将-Xmx和-Xms都设为1GB，或者-Xmx和-Xms设为1.2GB和1.8GB。
* Java中不能手动触发GC，但可以用不同的引用类来辅助垃圾回收器工作(比如：[弱引用或软引用](http://javarevisited.blogspot.com/2014/03/difference-between-weakreference-vs-softreference-phantom-strong-reference-java.html))。

以上就是关于Java中GC的一些内容。通过这篇博客，我们可以知道堆内存是如何划分的；一个对象在没有任何强引用指向他或该对象通过根节点不可达时需要被垃圾回收器回收；当垃圾收集器意识到需要进行GC时会触发Minor GC或Major GC，是自动的，无法强制执行。
### 参考文档(康桑阿米达~)
* [http://icyfenix.iteye.com/blog/715301](http://icyfenix.iteye.com/blog/715301)
* [http://www.cnblogs.com/zhguang/p/3257367.html](http://www.cnblogs.com/zhguang/p/3257367.html)
* [《深入理解java虚拟机》](https://www.amazon.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%A8%E5%BF%97%E6%98%8E/dp/B00D2ID4PK/ref=sr_1_1?ie=UTF8&qid=1463192894&sr=8-1&keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA)

------------------------------------------------其实我只是一条分割线---------------------------------------------------------
>关于永久代到底有没有GC还是很懵逼，很多地方看到的说法都不一致。欢迎指正错误，欢迎一起讨论~~

按国际惯例，wuli光洙结尾~~
![李光洙](/images/liguangzhu4.jpg)





